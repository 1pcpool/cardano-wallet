{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Data.QuantitySpec
    ( spec
    ) where

import Prelude

import Control.Monad
    ( forM_ )
import Data.Proxy
    ( Proxy (..) )
import Data.Quantity
    ( MkPercentageError (..), Percentage, Quantity (..), mkPercentage )
import Data.Text.Class
    ( FromText (..), TextDecodingError (..) )
import Test.Hspec
    ( Spec, describe, it, shouldBe )
import Test.QuickCheck
    ( Arbitrary (..)
    , arbitraryBoundedEnum
    , checkCoverage
    , cover
    , expectFailure
    , property
    , (===)
    )
import Test.Text.Roundtrip
    ( textRoundtrip )

import qualified Data.Aeson as Aeson
import qualified Data.Text as T


spec :: Spec
spec = do
    describe "Quantity" $ do
        textRoundtrip (Proxy @(Quantity "bytes" Int))

        it "fail to parse from JSON if unit doesn't match" $ do
            let msg =
                    "Error in $: failed to parse quantified value. Expected \
                    \value in 'bytes' (e.g. { \"unit\": \"bytes\", \"quantity\"\
                    \: ... }) but got something else."
            Aeson.eitherDecode "{\"unit\":\"patate\",\"quantity\":14}"
                `shouldBe`
                (Left @String @(Quantity "bytes" Int) msg)

    describe "Percentage" $ do
        textRoundtrip (Proxy @Percentage)

        describe "fromText failures" $ do
            let err = TextDecodingError
                    "expected a value between 0 and 100 with a '%' suffix \
                    \(e.g. '14%')"
            let tests =
                    [ "14.2%"
                    , "42%%"
                    , "%"
                    , "-65%"
                    , "42"
                    , "101%"
                    , "100% "
                    ]
            forM_ tests $ \test -> it (T.unpack test) $ do
                fromText @Percentage test `shouldBe` Left err

        it "fail to percent from JSON when out of bounds" $ do
            let msg = "Error in $.quantity: PercentageOutOfBoundsError"
            Aeson.eitherDecode "{\"unit\":\"percent\",\"quantity\":-14}"
                `shouldBe` (Left @String @(Quantity "percent" Percentage) msg)

        it "can't make percentage out of bound" $ checkCoverage $ \case
            n | n > 10 -> cover 25 True "n > 100" $
                -- NOTE taking 10 * n to get bigger Int generated by QuickCheck
                mkPercentage @Int (10 * n) === Left PercentageOutOfBoundsError
            n | n < 0 -> cover 25 True "n < 0" $
                mkPercentage @Int n === Left PercentageOutOfBoundsError
            n ->
                mkPercentage @Int n === Right (toEnum n)

        it "throw a runtime exception when 'toEnum' is used on invalid values" $
            expectFailure $ property $ \n -> toEnum @Percentage n `seq` ()

        it "roundtrip (toEnum . fromEnum)" $ property $ \(n :: Percentage) ->
            (toEnum . fromEnum) n === n

{-------------------------------------------------------------------------------
                              Arbitrary Instances
-------------------------------------------------------------------------------}

instance Arbitrary a => Arbitrary (Quantity u a) where
    shrink (Quantity a) = Quantity <$> shrink a
    arbitrary = Quantity <$> arbitrary

instance Arbitrary Percentage where
    shrink p
        | p == minBound = []
        | otherwise = [minBound]
    arbitrary = arbitraryBoundedEnum
